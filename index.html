<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Assistant Gateway Control Panel</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5',
                        'primary-dark': '#4338ca',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles for better readability and UI */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .card {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .response-box {
            white-space: pre-wrap;
            word-break: break-word;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8">

    <div class="max-w-4xl mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-3xl font-extrabold text-primary-dark sm:text-4xl">
                Gemini Assistant Gateway Control
            </h1>
            <p class="mt-2 text-gray-600">
                Test your deployed Gemini Assistant server endpoints.
            </p>
        </header>

        <!-- Configuration Section -->
        <div class="card bg-white p-6 rounded-xl mb-8">
            <h2 class="text-xl font-semibold mb-4 text-gray-800">Server Configuration</h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <input 
                    type="text" 
                    id="serverUrl" 
                    placeholder="Enter Hugging Face Space URL (e.g., https://user-appname.hf.space)" 
                    class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-primary focus:border-primary"
                    value=""
                >
                <button 
                    onclick="saveServerUrl()" 
                    class="bg-primary hover:bg-primary-dark text-white font-medium py-3 px-6 rounded-lg transition duration-150"
                >
                    Set URL
                </button>
            </div>
            <p id="urlStatus" class="mt-2 text-sm text-gray-500"></p>
        </div>

        <!-- Main Interface Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">

            <!-- 1. LLM Generation Panel -->
            <div class="card bg-white p-6 rounded-xl">
                <h2 class="text-xl font-semibold mb-4 text-gray-800 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 mr-2 text-primary"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2Zm-2 14v-4l2 4 2-4v4"></path></svg>
                    Text Generation (LLM)
                </h2>
                
                <label for="llmPrompt" class="block text-sm font-medium text-gray-700 mb-1">User Prompt</label>
                <textarea 
                    id="llmPrompt" 
                    rows="4" 
                    placeholder="Ask Gemini anything. E.g., 'What are the three main benefits of using an ESP32 for home automation?'" 
                    class="w-full p-3 border border-gray-300 rounded-lg resize-none focus:ring-primary focus:border-primary mb-3"
                ></textarea>

                <label for="systemPrompt" class="block text-sm font-medium text-gray-700 mb-1">System Instruction (Optional)</label>
                <input 
                    type="text" 
                    id="systemPrompt" 
                    placeholder="E.g., 'Respond in a pirate voice.'" 
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-primary focus:border-primary mb-4"
                >

                <button 
                    onclick="generateText()" 
                    id="llmButton"
                    class="w-full bg-primary hover:bg-primary-dark text-white font-semibold py-3 rounded-lg transition duration-150 mb-4 disabled:opacity-50"
                >
                    Generate Response
                </button>

                <!-- Response Area -->
                <h3 class="text-lg font-medium text-gray-800 mb-2">Response</h3>
                <div id="llmOutput" class="response-box bg-gray-50 border border-gray-200 p-3 rounded-lg text-sm text-gray-700">
                    Your response will appear here.
                </div>
                <p id="llmStatus" class="mt-2 text-sm text-red-500"></p>
            </div>

            <!-- 2. TTS Generation Panel -->
            <div class="card bg-white p-6 rounded-xl">
                <h2 class="text-xl font-semibold mb-4 text-gray-800 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 mr-2 text-primary"><path d="M10 16a2 2 0 0 1-2-2v-4a2 2 0 1 1 4 0v4a2 2 0 0 1-2 2z"></path><path d="M12 18v3"></path><path d="M8 21h8"></path><path d="M12 3c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8z"></path></svg>
                    Text-to-Speech (TTS)
                </h2>
                
                <label for="ttsText" class="block text-sm font-medium text-gray-700 mb-1">Text to Convert</label>
                <textarea 
                    id="ttsText" 
                    rows="4" 
                    placeholder="Enter the text you want converted to speech. Max 500 characters." 
                    class="w-full p-3 border border-gray-300 rounded-lg resize-none focus:ring-primary focus:border-primary mb-3"
                ></textarea>

                <label for="voiceSelect" class="block text-sm font-medium text-gray-700 mb-1">Select Voice</label>
                <select 
                    id="voiceSelect" 
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-primary focus:border-primary mb-4"
                >
                    <option value="Kore">Kore (Firm)</option>
                    <option value="Puck">Puck (Upbeat)</option>
                    <option value="Charon">Charon (Informative)</option>
                    <option value="Zephyr">Zephyr (Bright)</option>
                    <option value="Fenrir">Fenrir (Excitable)</option>
                    <option value="Leda">Leda (Youthful)</option>
                    <!-- More voices can be added -->
                </select>

                <button 
                    onclick="generateTTS()" 
                    id="ttsButton"
                    class="w-full bg-primary hover:bg-primary-dark text-white font-semibold py-3 rounded-lg transition duration-150 mb-4 disabled:opacity-50"
                >
                    Generate & Play Audio
                </button>

                <!-- Audio Playback Area -->
                <h3 class="text-lg font-medium text-gray-800 mb-2">Audio Playback</h3>
                <audio id="audioPlayer" controls class="w-full hidden"></audio>
                <div id="ttsOutput" class="response-box bg-gray-50 border border-gray-200 p-3 rounded-lg text-sm text-gray-700 flex items-center justify-center">
                    Click "Generate & Play Audio" to hear the result.
                </div>
                <p id="ttsStatus" class="mt-2 text-sm text-red-500"></p>
            </div>
        </div>
    </div>

    <script>
        const LLM_ENDPOINT = "/api/generate";
        const TTS_ENDPOINT = "/api/tts";
        
        // Configuration Elements
        const serverUrlInput = document.getElementById('serverUrl');
        const urlStatus = document.getElementById('urlStatus');
        
        // LLM Elements
        const llmPromptInput = document.getElementById('llmPrompt');
        const systemPromptInput = document.getElementById('systemPrompt');
        const llmButton = document.getElementById('llmButton');
        const llmOutput = document.getElementById('llmOutput');
        const llmStatus = document.getElementById('llmStatus');
        
        // TTS Elements
        const ttsTextInput = document.getElementById('ttsText');
        const voiceSelect = document.getElementById('voiceSelect');
        const ttsButton = document.getElementById('ttsButton');
        const audioPlayer = document.getElementById('audioPlayer');
        const ttsOutput = document.getElementById('ttsOutput');
        const ttsStatus = document.getElementById('ttsStatus');

        // Global variable for the base URL
        let SERVER_BASE_URL = '';

        document.addEventListener('DOMContentLoaded', () => {
            // Load saved URL from storage
            const savedUrl = localStorage.getItem('SERVER_BASE_URL');
            if (savedUrl) {
                SERVER_BASE_URL = savedUrl;
                serverUrlInput.value = savedUrl;
                urlStatus.textContent = 'Server URL loaded.';
                urlStatus.className = 'mt-2 text-sm text-green-600';
            } else {
                urlStatus.textContent = 'Please enter your Hugging Face Space URL above.';
                urlStatus.className = 'mt-2 text-sm text-red-500';
            }
        });

        function saveServerUrl() {
            const url = serverUrlInput.value.trim();
            if (url && url.startsWith('http')) {
                SERVER_BASE_URL = url.endsWith('/') ? url.slice(0, -1) : url;
                localStorage.setItem('SERVER_BASE_URL', SERVER_BASE_URL);
                urlStatus.textContent = `Server URL set to: ${SERVER_BASE_URL}`;
                urlStatus.className = 'mt-2 text-sm text-green-600';
            } else {
                urlStatus.textContent = 'Invalid URL. Must start with http(s).';
                urlStatus.className = 'mt-2 text-sm text-red-500';
            }
        }

        function checkServerUrl() {
            if (!SERVER_BASE_URL) {
                const errorMsg = 'Please set the Server URL first.';
                alertMessage(llmStatus, errorMsg);
                alertMessage(ttsStatus, errorMsg);
                return false;
            }
            return true;
        }

        function alertMessage(element, message) {
            element.textContent = message;
            setTimeout(() => { element.textContent = ''; }, 5000);
        }

        function setLLMLoading(isLoading) {
            llmButton.disabled = isLoading;
            llmButton.textContent = isLoading ? 'Generating...' : 'Generate Response';
            llmOutput.textContent = isLoading ? 'Waiting for server response...' : llmOutput.textContent;
            llmStatus.textContent = '';
        }

        function setTTSLoading(isLoading) {
            ttsButton.disabled = isLoading;
            ttsButton.textContent = isLoading ? 'Generating Audio...' : 'Generate & Play Audio';
            ttsOutput.textContent = isLoading ? 'Waiting for server response...' : ttsOutput.textContent;
            ttsStatus.textContent = '';
        }

        // --- LLM GENERATION ---
        async function generateText() {
            if (!checkServerUrl()) return;

            const userQuery = llmPromptInput.value.trim();
            const systemPrompt = systemPromptInput.value.trim();

            if (!userQuery) {
                alertMessage(llmStatus, 'Please enter a user prompt.');
                return;
            }

            setLLMLoading(true);
            
            try {
                const response = await fetch(`${SERVER_BASE_URL}${LLM_ENDPOINT}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userQuery, systemPrompt }),
                });

                const data = await response.json();
                
                if (response.ok) {
                    llmOutput.textContent = data.text;
                } else {
                    const errorDetails = data.details ? JSON.stringify(data.details, null, 2) : data.error;
                    llmOutput.textContent = `ERROR (${response.status}):\n${errorDetails}`;
                    alertMessage(llmStatus, 'Error generating text. Check console for details.');
                }
            } catch (error) {
                console.error('Fetch error:', error);
                llmOutput.textContent = 'Network or server connection error.';
                alertMessage(llmStatus, 'Connection failed. Check your server URL and console.');
            } finally {
                setLLMLoading(false);
            }
        }

        // --- TTS GENERATION ---
        async function generateTTS() {
            if (!checkServerUrl()) return;
            
            const textToSpeak = ttsTextInput.value.trim();
            const voiceName = voiceSelect.value;

            if (!textToSpeak) {
                alertMessage(ttsStatus, 'Please enter text to speak.');
                return;
            }

            setTTSLoading(true);
            audioPlayer.classList.add('hidden');
            audioPlayer.pause();
            
            try {
                const response = await fetch(`${SERVER_BASE_URL}${TTS_ENDPOINT}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ textToSpeak, voiceName }),
                });

                const data = await response.json();
                
                if (response.ok && data.audioData) {
                    ttsOutput.textContent = 'Audio data received. Converting to WAV and playing...';
                    
                    // Convert base64 PCM to WAV blob and play
                    const base64Data = data.audioData;
                    const sampleRate = 24000; // Hardcoded, as per typical Gemini TTS output rate

                    const pcmData = base64ToArrayBuffer(base64Data);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    audioPlayer.src = audioUrl;
                    audioPlayer.classList.remove('hidden');
                    audioPlayer.play();
                    
                    ttsOutput.textContent = 'Playback ready. (You can also download this file, but only the base64 data will be sent to the ESP32.)';
                    alertMessage(ttsStatus, 'Audio generated and playing!');

                } else {
                    const errorDetails = data.details ? JSON.stringify(data.details, null, 2) : data.error;
                    ttsOutput.textContent = `ERROR (${response.status}):\n${errorDetails}`;
                    alertMessage(ttsStatus, 'Error generating TTS. Check console for details.');
                }
            } catch (error) {
                console.error('Fetch error:', error);
                ttsOutput.textContent = 'Network or server connection error.';
                alertMessage(ttsStatus, 'Connection failed. Check your server URL and console.');
            } finally {
                setTTSLoading(false);
            }
        }

        // --- Audio Utility Functions ---
        // Helper to convert Base64 string to ArrayBuffer (required for PCM data)
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Converts signed 16-bit PCM data to a WAV Blob
        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit PCM

            const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
            const view = new DataView(buffer);

            // Helper function to write bytes
            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF'); // Chunk ID
            view.setUint32(4, 36 + pcm16.length * bytesPerSample, true); // Chunk Size
            writeString(view, 8, 'WAVE'); // Format

            // fmt sub-chunk
            writeString(view, 12, 'fmt '); // Sub-chunk 1 ID
            view.setUint32(16, 16, true); // Sub-chunk 1 Size (16 for PCM)
            view.setUint16(20, 1, true); // Audio Format (1 for PCM)
            view.setUint16(22, numChannels, true); // Num Channels
            view.setUint32(24, sampleRate, true); // Sample Rate
            view.setUint32(28, sampleRate * numChannels * bytesPerSample, true); // Byte Rate
            view.setUint16(32, numChannels * bytesPerSample, true); // Block Align
            view.setUint16(34, 16, true); // Bits Per Sample (16)

            // data sub-chunk
            writeString(view, 36, 'data'); // Sub-chunk 2 ID
            view.setUint32(40, pcm16.length * bytesPerSample, true); // Sub-chunk 2 Size

            // Write PCM data
            let offset = 44;
            for (let i = 0; i < pcm16.length; i++, offset += bytesPerSample) {
                view.setInt16(offset, pcm16[i], true); // Write 16-bit signed integer
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }
    </script>
</body>
</html>
